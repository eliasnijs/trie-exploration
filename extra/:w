.RP
.so macros.troff
.nr figstep 1 1
.TL
Analyse en Implementatie van Drie Trie Algoritmen
.AU
Elias Nijs
.AI
Algoritmen en Datastructuren 3
Universiteit Gent
.AB
We analyseren drie theoretische algoritmen voor het opslaan en zoeken van
multikey data, en implementeren voor elke van deze een praktische c
implementatie waarbij de sleutels ASCII strings zijn. Het eerste algoritme is
een arraytrie, meer bepaald de patriciatrie. Het tweede algoritme is een
combinatie van tries en binaire zoekbomen, de ternarytrie. Het laatste algoritme
is een combinatie van ternary tries en binaire semi-splay trees.
Tot slot zullen we deze 3 soorten tries met elkaar vergelijken op vlak van
snelheid en geheugengebruik.
.AE
.DA
.AM
.2C
.R1
accumulate
database bib.ref
.R2
.EQ
delim $$
.EN
.nr figstep 1 1
.NH 1
Introductie
.LP
Een trie, ook bekend als een digital tree of prefix tree, is een datastructuur
die gebruikt wordt voor het opslaan van multi-key data. Deze data bestaat
meestal uit verscheidene ASCII strings. Tries worden vaak gebruikt voor
het implementeren van dictionaries waar snelle opzoek, toevoeg en verwijder
operaties cruciaal zijn.

Over tijd zijn er verschillende soorten tries ontwikkeld, elk met hun eigen
eigenschappen en afwegingen. In dit verslag bespreken we 3 verschillende soorten
tries: de patricia trie
.[
	patricia
.]
, de ternary trie
.[
	ternary
.]
en tot slot een semi-splay ternary
trie.

De patricia trie is een geheugen-efficiente trie. Deze efficientie wordt bereikt
door enkel volledige woorden op te slaan, in plaats van alle mogelijke
voorvoegsels. Dit maak het ideaal voor toepassingen waar geheugen beperkt is.

De laatste trie die we zullen bekijken, de semisplay ternary trie, is een
variant van de ternary trie waarin de semisplay operatie verwerkt is. Het idee
achter deze boom is dat meer voorkomende prefixen dicther bij de wortel te
brengen en zo zoekoperaties te versnellen. In de analyse zal blijken of de tijd
die de splay operatie inneemt opweegt tegenover de gewonnen tijd.

In dit verslag zullen we de eigenschappen, implementaties en efficientie van
deze tries in detail bespreken. Daarnaast zullen we ook de verschillende tries
op vlak van geheugen gebruik en snelheid vergelijken met elkaar.
.NH 1
Algoritmes en hun Implementaties
.LP
In deze paragraaf zullen we de verschillende eigenschappen en implementaties
van de drie onderzochte tries bespreken.
.NH 2
PATRICIA
.LP
PATRICIA, kort voor
.I "Practical Algorithm To Retrieve Information Coded in Alphanumeric"
, is een trie structuur ontwikkeld door Donald R. Morrison in 1968. Deze trie is
een geheugen efficiente varient op de traditionele trie structuur. Het idee
achter deze efficientie is om enkel vertakkingen op te slaan en geen lange paden
waardoor het aantal nodes in de boom aanzienelijk daalt. Dit maakt de
trie bijzonder interessant voor applicaties waar geheugen beperkt is, zoals in
embedded systems.
.NH 3
Overslaan van karakters
.LP
Het overslaan van karakters is het cruciale idee achter de patricia trie en
waarom deze zo geheugen efficient is. Dit wordt bereikt door elke node een extra
variable
.I skip
te laten bijhouden die zegt hoeveel lettertekens er zonder vertakking zijn.

Bij het invoegen van een nieuwe key kan het natuurlijk gebeuren dat op het pad
dat we afgaan er een verschil is binnen de overgeslagen karakters van de node
waar we op dat moment zitten. Op dat moment is het noodzakelijk deze node in
twee te splitsen om een vertakking toe te voegen.
.NH 3
Geheugen vs Snelheid
.LP
Omwille van hoe ingewikkeld de invoeg operatie is bij patricia tries zullen we,
hoewel we geheugen gebruik besparen, veel tijd verliezen bij deze operatie. We
kunnen dit echter oplossen door een beetje geheugen gebruik op te offeren en met
dit geheugen de overgeslagen deelstrings bij te houden. Op deze manier kunnen we
tijdens een opzoek operatie al de prefixen vergelijken en hoeven we niet telkens
tot aan een blad te lopen.
.NH 3
Implementatie
.LP
De implemenatie kan teruggevonden worden onder
.CW "src/arraytrie.c" .


We bespreken nu kort enkele implementatie details.

We beginnen met de structuur van onze implementatie.
Deze ziet er als volgt uit:

.BD
.CW
.ps -1
struct atrie_node {
	char *ls;
	char *s;
	int16 m;
	struct atrie_node
		*next[ARRAYTRIE_ALPHASIZE];
};

struct atrie {
	struct atrie_node *root;
	size_t wc;
};
.ps +1
.DE

We hebben een wrapper
.I atrie
voor onze trie, deze houdt de wortel bij en hoeveel
woorden er aanwezig zijn. Dit laatste werd gedaan zodanig dat het opvragen van de grootte
van de trie aanzienelijk vereenvoudigd wordt.

Verder hebben we ook de structuur
.I atrie_node
voor onze nodes. Deze houdt een aantal verschillende zaken bij. Ten eerste houdt
deze een array met pointers bij. Elk van deze pointers zal naar een volgende
node wijzen indien deze een vervolg vormt op de huidige prefix. Verder houden we
ook
.I s
en
.I m
bij. Zoals in de vorige paragraaf besproken werd, kunnen we onze operaties
versnellen door de deelstring in elke node bij te houden. In deze implementatie werd
ervoor gekozen dit te gebruiken.
.I s
is een pointer naar de deelstring en
.I m
is de lengte van deze deelstring.
Tot slot hebben we ook nog
.I "ls".
Dit is de pointer naar de finale string in een blad. Indien de node geen blad
is, zal deze een null-pointer zijn. Op deze manier kunnen we deze pointer dus
ook gebruiken om te checken of we in een blad zitten.
Eventueel zouden we deze laatste variable nog kunnen weglaten en onze string op
bouwen tijdens de zoekoperatie. Op deze manier zouden we nog extra geheugen
kunnen besparen.

Onze implementatie ondersteunt alle verwachte operaties:
.IP \[bu] 2
.ps -1
.CW "init: void -> atrie "
.IP \[bu]
.ps -1
.CW "free: atrie -> void "
.IP \[bu]
.ps -1
.CW "search: (atrie, string) -> bool"
.IP \[bu]
.ps -1
.CW "add: (atrie, string) -> bool"
.IP \[bu]
.ps -1
.CW "remove:(atrie, string) -> bool"
.IP \[bu]
.ps -1
.CW "size: atrie -> size_t"
.ps +1
.LP
De implementaties van al deze zijn relatief straight-forward en worden hier dus
niet in detail bekeken.
.NH 3
Benchmarks
.PSPIC -C "images/array_all.eps"

.NH 2
Ternary Trie
.LP
Ternary tries zijn een trie structuur beschreven door J. Bentley en B.Sedgewick
in 1988. Deze structuur is een geheugen efficiente variant op de traditionele
trie. Het idee achter deze trie soort is om een volgend karakter voor te
stellen als een binaire boom die alle mogelijk volgende karakters bevat en daar
bovenop elke node een extra kind te geven die naar de volgende binaire boom
wijst. Omwille van de snelheid waarmee deze trie prefixen kan opzoeken, wordt
hij vaak gebruikt voor programmas zoals autocomplete.
.NH 3
Staart compressie
.LP
Om te voorkomen dat we op het einde lange staarten hebben zonder vertakking,
wordt er vaak geopteerd om de staart te comprimeren naar 1 node. We kunnen dit
op 2 manieren doen. De eerste manier is om telkens de volledige key op het einde
op te slaan en de tweede manier is om de resterende karakters van de key op het
einde op te slaan. Welke van deze 2 er gebruikt wordt is een afweging tussen
geheugen gebruik en snelheid.
.NH 3
Implementatie
.LP
De code voor deze trie val terug te vinden onder
.CW src/ternarytrie.c .

We beginnen met naar de structuur te kijken.
.BD
.CW
.ps -1
struct ttrie_node  {
	char *s;
	char splitchar;
	union {
		struct ttrie_node *cs[3];
		struct {
			struct ttrie_node
				*lo, *hi, *eq;
		};
	};
};
struct ttrie {
	struct ttrie_node *root;
	size_t wc;
};
.ps +1
.DE
.LP
We hebben een wrapper
.I ttrie
voor onze trie, deze houdt de wortel bij en hoeveel woorden er aanwezig zijn. Dit
laatste werd gedaan zodanig dat het opvragen van de grootte van de trie
aanzienelijk vereenvoudigd wordt.

Daarnaast hebben we ook de structuur
.I ttrie_node
die een node representeert.
Deze node houdt een aantal zaken bij. Het eerste dat deze node bijhoudt zijn de
pointers naar de volgende nodes. In onze structuur kunnen we deze op 2 manieren
addresseren. We kunnen ten eerste deze addresseren via de array
.I cs
en ten tweede met hun naam,
.I "lo, hi, eq".
Deze eerste manier was origineel niet aanwezig, maar werd later toegevoegd
zodat het addresseren van kinderen via een vergelijking mogelijk werd. Zo
kunnen we bijvoorbeeld het volgende doen.
.CODE "n = n->cs[c > n->splitchar]"
In dit voorbeeld zetten we n gelijk aan een van de kinderen van n. Indien c
groter is dan de splitchar van n, dan zal n gelijk gesteld worden aan
.CW n->hi
en anders aan
.CW "n->lo".

Verder bevat een node ook nog de splitchar. Dit is het karakter dat de node
representeert. En tot slot bevat de node ook nog een pointer
.I s
naar een string.
Deze string zal wijzen naar de volledige key indien de node een blad is en
anders zal deze een null-pointer zijn. Op deze manier kunnen we
.I s
gebruiken om te checken of de node een blad is.

Net zoals bij de patricia trie werden de volgende operaties geimplementeerd:
.IP \[bu] 2
.ps -1
.CW "init: void -> ttrie "
.IP \[bu]
.ps -1
.CW "free: ttrie -> void "
.IP \[bu]
.ps -1
.CW "search: (ttrie, string) -> bool"
.IP \[bu]
.ps -1
.CW "add: (ttrie, string) -> bool"
.IP \[bu]
.ps -1
.CW "remove:(ttrie, string) -> bool"
.IP \[bu]
.ps -1
.CW "size: ttrie -> size_t"
.ps +1
.LP
De search en add operaties werden iteratief geimplementeerd en de remove, free
en print operaties recursief. De implementaties van deze operaties zijn ook hier
allemaal relatief straight-forward en worden dus niet in detail bekeken.

Tot slot werden er 2 custom allocators gemaakt. De eerste is een arena
allocator en de andere een pooling allocator. De implementatie met uitleg over
hoe deze werken valt terug te vinden onder
.IP \[bu] 2
.CW src/utils/m_arena.c
.IP \[bu]
.CW src/utils/m_pool.c
.LP
Deze zijn in staat om een signficante boost in performance te geven door het
uitsparen van veel dure malloc/calloc operaties en doordat er minder geheugen
fragmentatie optreedt.
Helaas kunnen deze enkel gebruikt worden indien men een goede bovengrens kan
bepalen voor hoeveel geheugen men nodig heeft. Om deze te gebruiken moet men
immers op voorhand een grote buffer waar de allocators op geldig zijn
reserveren. Een bijkomend voordeel is dat men de hele trie in e\*[']e\*[']n
operatie kan vrijgeven door de backbuffer vrij te geven.
.NH 3
Complexiteit
.LP
De complexiteit van deze boom is O(m).

We kunnen dit ook verifieren aan de hand van een kleine benchmark.
.PSPIC -C "images/ternary_all.eps"




.NH 2
Semisplay Ternary Trie
.LP
 ...

.NH 1
Analyse
.LP
 ...



.NH 1
padding
.lp
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
this is padding! this is padding! this is padding! this is padding!
